<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src 'unsafe-inline'; script-src 'unsafe-inline'; media-src data:;">
  <style>{{CSS}}</style>
</head>
<body>
  <div class="container">
    <!-- Header -->
    <header class="header">
      <h1>Vocalize MD</h1>
      <div class="header-right">
        <div class="status-indicators" id="statusIndicators">
          <span class="status-icon" id="deepgramStatus" title="Deepgram TTS: Converts text to speech">
            <svg viewBox="0 0 24 24"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/></svg>
          </span>
          <span class="status-icon" id="openrouterStatus" title="OpenRouter/Gemini: Processes markdown to readable text">
            <svg viewBox="0 0 24 24"><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"/></svg>
          </span>
          <span class="status-icon" id="assemblyStatus" title="AssemblyAI: Provides accurate word timestamps for sync">
            <svg viewBox="0 0 24 24"><path d="M12 15c1.66 0 2.99-1.34 2.99-3L15 6c0-1.66-1.34-3-3-3S9 4.34 9 6v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 15 6.7 12H5c0 3.42 2.72 6.23 6 6.72V22h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z"/></svg>
          </span>
        </div>
        <button class="icon-btn" id="settingsBtn" title="Settings">
          <svg viewBox="0 0 24 24"><path d="M19.14 12.94c.04-.31.06-.63.06-.94 0-.31-.02-.63-.06-.94l2.03-1.58a.49.49 0 00.12-.61l-1.92-3.32a.49.49 0 00-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54a.484.484 0 00-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96a.49.49 0 00-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.04.31-.06.63-.06.94s.02.63.06.94l-2.03 1.58a.49.49 0 00-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/></svg>
        </button>
      </div>
    </header>

    <!-- Player Controls -->
    <div class="player">
      <div class="controls">
        <button class="ctrl-btn" id="rewindBtn" title="Rewind 10s">
          <svg viewBox="0 0 24 24"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/><text x="12" y="15" font-size="6" text-anchor="middle" fill="currentColor">10</text></svg>
        </button>
        <button class="play-btn" id="playBtn" title="Play">
          <svg class="play-icon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
          <svg class="pause-icon hidden" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
        </button>
        <button class="ctrl-btn" id="forwardBtn" title="Forward 10s">
          <svg viewBox="0 0 24 24"><path d="M12 5V1l5 5-5 5V7c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6h2c0 4.42-3.58 8-8 8s-8-3.58-8-8 3.58-8 8-8z"/><text x="12" y="15" font-size="6" text-anchor="middle" fill="currentColor">10</text></svg>
        </button>
      </div>
      
      <div class="progress-wrap">
        <input type="range" class="progress" id="progress" min="0" max="100" value="0" step="0.1">
        <div class="time">
          <span id="current">0:00</span>
          <span id="duration">0:00</span>
        </div>
      </div>

      <div class="bottom-controls">
        <button class="speed-btn" id="speedBtn" title="Playback speed">1√ó</button>
        
        <div class="view-toggle" id="viewToggle">
          <button class="view-btn active" id="captionsBtn" title="Captions view">
            <svg viewBox="0 0 24 24"><path d="M19 4H5c-1.11 0-2 .9-2 2v12c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-8 7H9.5v-.5h-2v3h2V13H11v1c0 .55-.45 1-1 1H7c-.55 0-1-.45-1-1v-4c0-.55.45-1 1-1h3c.55 0 1 .45 1 1v1zm7 0h-1.5v-.5h-2v3h2V13H18v1c0 .55-.45 1-1 1h-3c-.55 0-1-.45-1-1v-4c0-.55.45-1 1-1h3c.55 0 1 .45 1 1v1z"/></svg>
          </button>
          <button class="view-btn" id="fullTextBtn" title="Full text view">
            <svg viewBox="0 0 24 24"><path d="M14 17H4v2h10v-2zm6-8H4v2h16V9zM4 15h16v-2H4v2zM4 5v2h16V5H4z"/></svg>
          </button>
        </div>
      </div>
    </div>

    <!-- Text Display -->
    <div class="text-area" id="textArea">
      <div class="placeholder">
        <p>Click the üîä speaker icon on any markdown file to start</p>
      </div>
    </div>
  </div>

  <script>
    const vscode = acquireVsCodeApi();
    
    let audio = null;
    let sentenceElements = [];
    let sentenceTimings = []; // {start, end} for each sentence
    let speed = 1;
    const speeds = [0.75, 1, 1.25, 1.5, 2];
    let speedIndex = 1;
    let animationId = null;
    let currentSentenceIdx = -1;
    let viewMode = 'synced'; // 'synced' (beta), 'captions', or 'fulltext'
    let fullText = '';
    let hasAccurateTimestamps = false;

    const playBtn = document.getElementById('playBtn');
    const rewindBtn = document.getElementById('rewindBtn');
    const forwardBtn = document.getElementById('forwardBtn');
    const speedBtn = document.getElementById('speedBtn');
    const settingsBtn = document.getElementById('settingsBtn');
    const captionsBtn = document.getElementById('captionsBtn');
    const fullTextBtn = document.getElementById('fullTextBtn');
    const viewToggle = document.getElementById('viewToggle');
    const progress = document.getElementById('progress');
    const currentEl = document.getElementById('current');
    const durationEl = document.getElementById('duration');
    const textArea = document.getElementById('textArea');
    const deepgramStatus = document.getElementById('deepgramStatus');
    const openrouterStatus = document.getElementById('openrouterStatus');
    const assemblyStatus = document.getElementById('assemblyStatus');

    function updateStatusIndicators(apiStatus) {
      if (!apiStatus) return;
      
      // Deepgram status (music note icon - TTS)
      deepgramStatus.classList.toggle('active', apiStatus.deepgram);
      deepgramStatus.classList.toggle('inactive', !apiStatus.deepgram);
      deepgramStatus.title = apiStatus.deepgram 
        ? '‚úì Deepgram TTS: Active\nConverts text to speech' 
        : '‚úó Deepgram TTS: Not configured\nAdd API key in settings';
      
      // OpenRouter status (code icon - AI processing)
      openrouterStatus.classList.toggle('active', apiStatus.openrouter);
      openrouterStatus.classList.toggle('inactive', !apiStatus.openrouter);
      openrouterStatus.title = apiStatus.openrouter 
        ? '‚úì OpenRouter/Gemini: Active\nProcesses markdown to readable text' 
        : '‚úó OpenRouter/Gemini: Not configured\nAdd API key in settings';
      
      // AssemblyAI status (mic icon - transcription)
      assemblyStatus.classList.toggle('active', apiStatus.assemblyai);
      assemblyStatus.classList.toggle('inactive', !apiStatus.assemblyai);
      assemblyStatus.title = apiStatus.assemblyai 
        ? '‚úì AssemblyAI: Active\nProvides accurate word timestamps' 
        : '‚óã AssemblyAI: Disabled\nEnable in settings for better sync';
    }

    function formatTime(s) {
      const m = Math.floor(s / 60);
      const sec = Math.floor(s % 60);
      return m + ':' + sec.toString().padStart(2, '0');
    }

    function highlightCurrentSentence() {
      if (!audio || !sentenceTimings.length) return;
      
      const currentTime = audio.currentTime;
      
      // Find sentence at current time
      let activeIdx = -1;
      for (let i = 0; i < sentenceTimings.length; i++) {
        if (currentTime >= sentenceTimings[i].start && currentTime < sentenceTimings[i].end) {
          activeIdx = i;
          break;
        }
      }
      
      // Also check if we're past all sentences (for edge case at end)
      if (activeIdx === -1 && sentenceTimings.length > 0) {
        const lastSentence = sentenceTimings[sentenceTimings.length - 1];
        if (currentTime >= lastSentence.start) {
          activeIdx = sentenceTimings.length - 1;
        }
      }
      
      // Update display if sentence changed
      if (activeIdx !== currentSentenceIdx && activeIdx >= 0) {
        currentSentenceIdx = activeIdx;
        
        if (viewMode === 'captions') {
          // In captions mode, show only the current sentence
          const captionEl = textArea.querySelector('.caption-text');
          if (captionEl && sentenceTimings[activeIdx]) {
            captionEl.textContent = sentenceTimings[activeIdx].text;
            captionEl.classList.add('fade-in');
            setTimeout(() => captionEl.classList.remove('fade-in'), 300);
          }
        } else if (viewMode === 'synced') {
          // In synced mode, highlight current sentence and scroll
          sentenceElements.forEach((el, i) => {
            el.classList.toggle('active', i === activeIdx);
          });
          
          if (sentenceElements[activeIdx]) {
            sentenceElements[activeIdx].scrollIntoView({ 
              behavior: 'smooth', 
              block: 'center'
            });
          }
        }
      }
    }

    // Use a more frequent update interval for better sync at high speeds
    let syncInterval = null;
    
    function startSyncInterval() {
      stopSyncInterval();
      // Update every 50ms for smooth sync at all speeds
      syncInterval = setInterval(() => {
        if (audio && !audio.paused && viewMode !== 'fulltext') {
          highlightCurrentSentence();
        }
      }, 50);
    }
    
    function stopSyncInterval() {
      if (syncInterval) {
        clearInterval(syncInterval);
        syncInterval = null;
      }
    }

    function updateProgress() {
      if (!audio) return;
      const pct = (audio.currentTime / audio.duration) * 100 || 0;
      progress.value = pct;
      progress.style.background = `linear-gradient(to right, #4fc3f7 ${pct}%, #333 ${pct}%)`;
      currentEl.textContent = formatTime(audio.currentTime);
      
      if (!audio.paused) {
        animationId = requestAnimationFrame(updateProgress);
      }
    }

    function setPlaying(playing) {
      playBtn.querySelector('.play-icon').classList.toggle('hidden', playing);
      playBtn.querySelector('.pause-icon').classList.toggle('hidden', !playing);
      
      if (playing) {
        animationId = requestAnimationFrame(updateProgress);
        startSyncInterval();
      } else {
        if (animationId) {
          cancelAnimationFrame(animationId);
        }
        stopSyncInterval();
      }
    }

    function renderSyncedView() {
      viewMode = 'synced';
      captionsBtn.classList.add('active');
      fullTextBtn.classList.remove('active');
      
      // Render sentences with highlighting (beta sync)
      const betaLabel = hasAccurateTimestamps ? '' : '<span class="beta-label">BETA</span>';
      textArea.innerHTML = '<div class="synced-text">' + betaLabel +
        sentenceTimings.map((s, i) => `<p class="sentence" data-index="${i}">${s.text}</p>`).join('') + 
        '</div>';
      sentenceElements = Array.from(textArea.querySelectorAll('.sentence'));
      
      // Add click-to-jump functionality
      sentenceElements.forEach((el, i) => {
        el.addEventListener('click', () => {
          if (audio && sentenceTimings[i]) {
            audio.currentTime = sentenceTimings[i].start;
            currentSentenceIdx = -1;
            highlightCurrentSentence();
            if (audio.paused) {
              audio.play().then(() => setPlaying(true)).catch(() => {});
            }
          }
        });
      });
      
      // Restore highlight
      currentSentenceIdx = -1;
      highlightCurrentSentence();
    }

    function renderCaptionsView() {
      viewMode = 'captions';
      captionsBtn.classList.add('active');
      fullTextBtn.classList.remove('active');
      
      // Show single caption at a time
      textArea.innerHTML = '<div class="captions-container"><p class="caption-text"></p></div>';
      
      // Show current sentence
      currentSentenceIdx = -1;
      if (audio && sentenceTimings.length) {
        highlightCurrentSentence();
        // If no sentence is active yet, show the first one
        if (currentSentenceIdx === -1 && sentenceTimings[0]) {
          textArea.querySelector('.caption-text').textContent = sentenceTimings[0].text;
        }
      }
    }

    function renderFullTextView() {
      viewMode = 'fulltext';
      fullTextBtn.classList.add('active');
      captionsBtn.classList.remove('active');
      
      // Show all text without syncing
      textArea.innerHTML = '<div class="fulltext-container"><p class="fulltext">' + fullText + '</p></div>';
    }

    playBtn.onclick = () => {
      if (!audio) return;
      if (audio.paused) {
        audio.play();
        setPlaying(true);
      } else {
        audio.pause();
        setPlaying(false);
      }
    };

    rewindBtn.onclick = () => { if (audio) audio.currentTime = Math.max(0, audio.currentTime - 10); };
    forwardBtn.onclick = () => { if (audio) audio.currentTime = Math.min(audio.duration, audio.currentTime + 10); };

    speedBtn.onclick = () => {
      speedIndex = (speedIndex + 1) % speeds.length;
      speed = speeds[speedIndex];
      speedBtn.textContent = speed + '√ó';
      if (audio) audio.playbackRate = speed;
    };

    settingsBtn.onclick = () => vscode.postMessage({ command: 'openSettings' });
    
    captionsBtn.onclick = () => {
      if (hasAccurateTimestamps) {
        if (viewMode !== 'captions') renderCaptionsView();
      } else {
        if (viewMode !== 'synced') renderSyncedView();
      }
    };
    
    fullTextBtn.onclick = () => {
      if (viewMode !== 'fulltext') renderFullTextView();
    };

    progress.oninput = () => {
      if (audio) {
        audio.currentTime = (progress.value / 100) * audio.duration;
        currentSentenceIdx = -1; // Reset to force update
        highlightCurrentSentence();
      }
    };

    // Split text into sentences
    function splitIntoSentences(text) {
      return text.split(/(?<=[.!?])\s+/).filter(s => s.trim());
    }

    // Build sentence timings from word timings
    function buildSentenceTimings(text, wordTimings) {
      const sentences = splitIntoSentences(text);
      const timings = [];
      let wordIdx = 0;
      
      for (const sentence of sentences) {
        const sentenceWords = sentence.split(/\s+/).filter(w => w);
        const wordCount = sentenceWords.length;
        
        if (wordIdx < wordTimings.length) {
          const start = wordTimings[wordIdx].start;
          const endIdx = Math.min(wordIdx + wordCount - 1, wordTimings.length - 1);
          const end = wordTimings[endIdx].end;
          timings.push({ start, end, text: sentence });
          wordIdx += wordCount;
        }
      }
      
      return timings;
    }

    window.addEventListener('message', e => {
      const msg = e.data;
      
      if (msg.type === 'status') {
        textArea.innerHTML = `<div class="loading"><div class="spinner"></div><p>${msg.message}</p></div>`;
        if (audio) { audio.pause(); audio = null; }
        if (animationId) cancelAnimationFrame(animationId);
        setPlaying(false);
        currentSentenceIdx = -1;
      }
      
      if (msg.type === 'error') {
        textArea.innerHTML = `<div class="error"><p>‚ö†Ô∏è ${msg.message}</p></div>`;
      }
      
      if (msg.type === 'ready') {
        const wordTimings = msg.words || [];
        currentSentenceIdx = -1;
        fullText = msg.text;
        hasAccurateTimestamps = msg.useAccurateTimestamps || false;
        
        // Update status indicators
        updateStatusIndicators(msg.apiStatus);
        
        // Update captions button tooltip based on mode
        captionsBtn.title = hasAccurateTimestamps ? 'Captions view' : 'Synced view (beta)';
        
        // Build sentence timings from word timings
        if (wordTimings.length) {
          sentenceTimings = buildSentenceTimings(msg.text, wordTimings);
        } else {
          // Fallback: estimate timings based on text length
          const sentences = splitIntoSentences(msg.text);
          const totalChars = sentences.reduce((sum, s) => sum + s.length, 0);
          let currentTime = 0;
          sentenceTimings = sentences.map(s => {
            const duration = (s.length / totalChars) * (msg.estimatedDuration || 60);
            const timing = { start: currentTime, end: currentTime + duration, text: s };
            currentTime += duration;
            return timing;
          });
        }
        
        // Render based on timestamps availability
        if (hasAccurateTimestamps) {
          renderCaptionsView();
        } else {
          renderSyncedView();
        }
        
        // Setup audio
        audio = new Audio('data:audio/mpeg;base64,' + msg.audio);
        audio.playbackRate = speed;
        
        audio.onloadedmetadata = () => {
          durationEl.textContent = formatTime(audio.duration);
          
          // Update fallback timings with actual duration
          if (!wordTimings.length && audio.duration) {
            const sentences = splitIntoSentences(msg.text);
            const totalChars = sentences.reduce((sum, s) => sum + s.length, 0);
            let currentTime = 0;
            sentenceTimings = sentences.map(s => {
              const duration = (s.length / totalChars) * audio.duration;
              const timing = { start: currentTime, end: currentTime + duration, text: s };
              currentTime += duration;
              return timing;
            });
          }
        };
        
        audio.onended = () => {
          setPlaying(false);
          if (viewMode === 'synced') {
            sentenceElements.forEach(s => s.classList.remove('active'));
          }
          currentSentenceIdx = -1;
        };
        
        // Auto-play
        audio.play().then(() => setPlaying(true)).catch(() => {});
      }
    });
  </script>
</body>
</html>
